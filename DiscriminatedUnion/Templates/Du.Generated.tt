<#@ template language="C#" hostspecific="true" #>
<#@ import namespace="System.Linq" #>
<#@ include file="Shared.ttinclude" #>
using System.Collections.Immutable;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Text.Json;
using System.Text.Json.Serialization;

#nullable enable

namespace NickStrupat;
<#
for (var i = 1; i != MaxDuTypes; i++)
{
	var range = Enumerable.Range(1, i + 1).ToArray();
	var gps = String.Join(", ", from n in range select $"T{n}");
	var duName = $"Du<{gps}>";
	var cons = String.Join("\n\t", from n in range select $"where T{n} : notnull");
	var matchParams = String.Join(", ", from n in range select $"Func<T{n}, TResult> f{n}");
	var switchParams = String.Join(", ", from n in range select $"Action<T{n}> a{n}");
	var toStringArgs = String.Join(", ", from n in range select "Du.ToStr");
	var getHashCodeArgs = String.Join(", ", from n in range select "Du.GetHc");
	var commas = new String(',', i);
#>

[JsonConverter(typeof(DuJsonConverter))]
[DebuggerTypeProxy(typeof(Du<<#=commas#>>.DebugView))]
public readonly struct <#=duName#>
	: IEquatable<<#=duName#>>
	, IDu<<#=duName#>>
	<#=cons#>
{
	private readonly UnmanagedStorage unmanaged;
	private readonly Object? managed;

	private T Get<T>() => Du.Get<T>(managed, in unmanaged);

	private Byte GetIndexUnsafe() => Du.GetIndexUnsafe(managed, in unmanaged);
	private Byte GetIndex() => Du.GetIndex(managed, in unmanaged);

<#foreach (var n in range) {#>
	public Du(T<#=n#> instance<#=n#>) => (managed, unmanaged) = Du.Init(ref instance<#=n#>, <#=n#>);
<#}#>

<#foreach (var n in range) {#>
	public static implicit operator <#=duName#>(T<#=n#> value) => new(value);
<#}#>

	public Boolean TryPick<T>([NotNullWhen(true)] out T? matched) where T : notnull
	{
		switch (GetIndex())
		{
<#foreach (var n in range) {#>
			case <#=n#> when typeof(T) == typeof(T<#=n#>):
<#}#>
				matched = Get<T>();
				return true;
			default:
				matched = default!;
				return false;
		}
	}

	public void Visit<T>(Action<T> action) where T : notnull
	{
		if (TryPick(out T? matched))
			action(matched);
	}

	public void Visit<TVisitor>(TVisitor visitor) where TVisitor : IVisitor
	{
		switch (GetIndexUnsafe())
		{
<#foreach (var n in range) {#>
			case <#=n#>: visitor.Visit(Get<T<#=n#>>()); break;
<#}#>
			default: throw new InvalidInstanceException();
		}
	}

	public TResult Visit<TVisitor, TResult>(TVisitor visitor) where TVisitor : IVisitor<TResult>
	{
		switch (GetIndexUnsafe())
		{
			case 1: return visitor.Visit(Get<T1>());
			case 2: return visitor.Visit(Get<T2>());
			default: throw new InvalidInstanceException();
		}
	}

	public TResult Match<TResult>(<#=matchParams#>) => GetIndexUnsafe() switch
	{
<#foreach (var n in range) {#>
		<#=n#> => f<#=n#>(Get<T<#=n#>>()),
<#}#>
		_ => throw new InvalidInstanceException()
	};

	public void Switch(<#=switchParams#>)
	{
		switch (GetIndexUnsafe())
		{
<#foreach (var n in range) {#>
			case <#=n#>: a<#=n#>(Get<T<#=n#>>()); break;
<#}#>
			default: throw new InvalidInstanceException();
		}
	}

	public static ImmutableArray<Type> Types { get; } = [
<#foreach (var n in range) {#>
		typeof(T<#=n#>),
<#}#>
	];

	public static <#=duName#> Deserialize(ref Utf8JsonReader reader, JsonSerializerOptions options)
	{
<#foreach (var n in range) {#>
		if (JsonSerializer.TryDeserialize<T<#=n#>>(ref reader, options, out var v<#=n#>) && v<#=n#> is not null)
			return v<#=n#>;
<#}#>
		throw new JsonException("No match was found for converting the JSON into a " + typeof(<#=duName#>).NameWithGenericArguments);
	}

	public void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options) => Visit(new JsonSerializerVisitor(writer, options));

	public override String ToString() => Visit<ToStringVisitor, String>(default);

	public override Int32 GetHashCode() => Visit<GetHashCodeVisitor, Int32>(default);

	public override Boolean Equals([NotNullWhen(true)] Object? obj) => obj switch
	{
		<#=duName#> du => Equals(du),
<#foreach (var n in range) {#>
		T<#=n#> t when GetIndex() == <#=n#> => Get<T<#=n#>>()?.Equals(t) ?? false,
<#}#>
		IDu du => Visit<DuEqualityVisitor, Boolean>(new(du)),
		_ => false
	};

	public Boolean Equals(<#=duName#> other) => (GetIndex(), other.GetIndex()) switch
	{
<#foreach (var n in range) {#>
		(<#=n#>, <#=n#>) => Equals<T<#=n#>>(other),
<#}#>
		_ => false
	};

	private Boolean Equals<T>(<#=duName#> other) => (Get<T>(), other.Get<T>()) switch
	{
		(null, null) => true,
		(null, not null) or (not null, null) => false,
		var (x, y) => x.Equals(y)
	};

	public Boolean Equals<T>(T other) where T : notnull =>
		TryPick(out T? matched) && EqualityComparer<T>.Default.Equals(matched, other);

	public static Boolean operator ==(<#=duName#> left, <#=duName#> right) => left.Equals(right);
	public static Boolean operator !=(<#=duName#> left, <#=duName#> right) => !(left == right);

	private sealed class DebugView
	{
		private readonly <#=duName#> du;
		public DebugView(<#=duName#> du) => this.du = du;

		public UnmanagedStorage unmanaged => du.unmanaged;
		public Object? managed => du.managed;

		public Byte Index => du.GetIndex();

		public Object? Value => du.GetIndex() switch
		{
<#foreach (var n in range) {#>
			<#=n#> => du.Get<T<#=n#>>(),
<#}#>
			_ => null
		};
	}
}
<#
	// var templateDirectory = Path.GetDirectoryName(Host.TemplateFile) ?? throw new("ruh roh");
	// var outputFilePath = Path.Combine(templateDirectory, $"Du_{i + 1}.cs");
	// File.WriteAllText(outputFilePath, this.GenerationEnvironment.ToString());
	// this.GenerationEnvironment.Remove(0, this.GenerationEnvironment.Length);
}
#>
