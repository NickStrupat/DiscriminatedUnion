<#@ template language="C#" hostspecific="true" #>
<#@ import namespace="System.Linq" #>
<#@ include file="Shared.ttinclude" #>
using System.Collections.Immutable;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Text.Json;
using System.Text.Json.Serialization;

#nullable enable

namespace NickStrupat;
<#
for (var i = 1; i != MaxDuTypes; i++)
{
	var range = Enumerable.Range(1, i + 1).ToArray();
	var gps = String.Join(", ", from n in range select $"T{n}");
	var duName = $"Du<{gps}>";
	var cons = String.Join("\n\t", from n in range select $"where T{n} : notnull");
	var matchParams = String.Join(", ", from n in range select $"Func<T{n}, TResult> f{n}");
	var switchParams = String.Join(", ", from n in range select $"Action<T{n}> a{n}");
	var toStringArgs = String.Join(", ", from n in range select "Du.ToStr");
	var getHashCodeArgs = String.Join(", ", from n in range select "Du.GetHc");
	var commas = new String(',', i);
#>

[JsonConverter(typeof(DuJsonConverter))]
[DebuggerTypeProxy(typeof(Du.DebugView))]
public readonly struct <#=duName#>
	: IEquatable<<#=duName#>>
	, IDu<<#=duName#>>
	<#=cons#>
{
	internal readonly UnmanagedStorage unmanaged;
	internal readonly Object? managed;

	private T Get<T>() where T : notnull => Du.Get<T>(managed, in unmanaged);

	private Byte GetIndexUnsafe() => Du.GetIndexUnsafe(managed, in unmanaged);
	private Byte GetIndex() => Du.GetIndex(managed, in unmanaged);

	private static <#=duName#> InitUnsafe<T>(ref T instance, Byte index) where T : notnull => new(Du.Init(ref instance, index));
	private Du((Object? managed, UnmanagedStorage unmanaged) x) => (this.managed, this.unmanaged) = (x.managed, x.unmanaged);
<#foreach (var n in range) {#>
	public Du(T<#=n#> instance<#=n#>) : this(Du.Init(ref instance<#=n#>, <#=n#>)) { }
<#}#>

<#foreach (var n in range) {#>
	public static implicit operator <#=duName#>(T<#=n#> value) => new(value);
<#}#>

	public TResult Accept<TVisitor, TResult>(TVisitor visitor) where TVisitor : IVisitor<TResult>
		=> Accept<TVisitor, TResult>(ref visitor);

	public TResult Accept<TVisitor, TResult>(ref TVisitor visitor) where TVisitor : IVisitor<TResult>
	{
		switch (GetIndexUnsafe())
		{
<#foreach (var n in range) {#>
			case <#=n#>: return visitor.Visit(Get<T<#=n#>>());
<#}#>
			default: throw new InvalidInstanceException();
		}
	}

	public static Boolean TryCreate<T>(T value, out <#=duName#> du)
	{
<#foreach (var n in range) {#>
		if (value is T<#=n#> v<#=n#>) { du = v<#=n#>; return true; }
<#}#>
		du = default;
		return false;
	}

	public static Boolean AcceptTypes<TTypeVisitor, TRefParam>(ref TTypeVisitor visitor, ref TRefParam refArg) where TTypeVisitor : ITypeVisitor<<#=duName#>, TRefParam> where TRefParam : allows ref struct
	{
<#foreach (var n in range) {#>
		if (visitor.VisitType<T<#=n#>>(ref refArg, static x => new(x))) return true;
<#}#>
		return false;
	}

	public TResult Match<TResult>(<#=matchParams#>)
	{
		switch (GetIndexUnsafe())
		{
<#foreach (var n in range) {#>
			case <#=n#>: return f<#=n#>(Get<T<#=n#>>());
<#}#>
			default: throw new InvalidInstanceException();
		}
	}

	public void Switch(<#=switchParams#>)
	{
		switch (GetIndexUnsafe())
		{
<#foreach (var n in range) {#>
			case <#=n#>: a<#=n#>(Get<T<#=n#>>()); break;
<#}#>
			default: throw new InvalidInstanceException();
		}
	}

	public static ImmutableArray<Type> Types { get; } = [
<#foreach (var n in range) {#>
		typeof(T<#=n#>),
<#}#>
	];

	public override String ToString() => Accept<ToStringVisitor, String>(default);

	public override Int32 GetHashCode() => Accept<GetHashCodeVisitor, Int32>(default);

	public override Boolean Equals([NotNullWhen(true)] Object? obj) => obj switch
	{
		<#=duName#> du => Equals(du),
<#foreach (var n in range) {#>
		T<#=n#> t when GetIndex() == <#=n#> => Get<T<#=n#>>().Equals(t),
<#}#>
		IDu du => Accept<DuEqualityVisitor<IDu>, Boolean>(new(du)),
		_ => false
	};

	public Boolean Equals(<#=duName#> other) => Accept<DuEqualityVisitor<<#=duName#>>, Boolean>(new(other));

	public static Boolean operator ==(<#=duName#> left, <#=duName#> right) => left.Equals(right);
	public static Boolean operator !=(<#=duName#> left, <#=duName#> right) => !(left == right);
}
<#
	// var templateDirectory = Path.GetDirectoryName(Host.TemplateFile) ?? throw new("ruh roh");
	// var outputFilePath = Path.Combine(templateDirectory, $"Du_{i + 1}.cs");
	// File.WriteAllText(outputFilePath, this.GenerationEnvironment.ToString());
	// this.GenerationEnvironment.Remove(0, this.GenerationEnvironment.Length);
}
#>
