<#@ template language="C#" hostspecific="true" #>
<#@ import namespace="System.Linq" #>
<#@ include file="Shared.ttinclude" #>
using System.Collections.Immutable;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Text.Json;
using System.Text.Json.Serialization;

#nullable enable

namespace NickStrupat;
<#
for (var i = 1; i != MaxDuTypes; i++)
{
	var range = Enumerable.Range(1, i + 1).ToArray();
	var gps = String.Join(", ", from n in range select $"T{n}");
	var duName = $"Du<{gps}>";
	var cons = String.Join("\n\t", from n in range select $"where T{n} : notnull");
	var matchParams = String.Join(", ", from n in range select $"Func<T{n}, TResult> f{n}");
	var switchParams = String.Join(", ", from n in range select $"Action<T{n}> a{n}");
	var toStringArgs = String.Join(", ", from n in range select "Du.ToStr");
	var getHashCodeArgs = String.Join(", ", from n in range select "Du.GetHc");
	var commas = new String(',', i);
#>

[JsonConverter(typeof(DuJsonConverter))]
[DebuggerTypeProxy(typeof(Du.DebugView))]
public readonly struct <#=duName#>
	: IEquatable<<#=duName#>>
	, IDu<<#=duName#>>
	<#=cons#>
{
	internal readonly UnmanagedStorage unmanaged;
	internal readonly Object? managed;

	private T Get<T>() where T : notnull => Du.Get<T>(managed, in unmanaged);

	private Byte GetIndexUnsafe() => Du.GetIndexUnsafe(managed, in unmanaged);
	private Byte GetIndex() => Du.GetIndex(managed, in unmanaged);

<#foreach (var n in range) {#>
	public Du(T<#=n#> instance<#=n#>) => (managed, unmanaged) = Du.Init(ref instance<#=n#>, <#=n#>);
<#}#>

<#foreach (var n in range) {#>
	public static implicit operator <#=duName#>(T<#=n#> value) => new(value);
<#}#>

	public TResult Visit<TVisitor, TResult>(TVisitor visitor) where TVisitor : IVisitor<TResult>
		=> Visit<TVisitor, TResult>(ref visitor);

	public TResult Visit<TVisitor, TResult>(ref TVisitor visitor) where TVisitor : IVisitor<TResult>
	{
		switch (GetIndexUnsafe())
		{
<#foreach (var n in range) {#>
			case <#=n#>: return visitor.Visit(Get<T<#=n#>>());
<#}#>
			default: throw new InvalidInstanceException();
		}
	}

	public TResult Match<TResult>(<#=matchParams#>)
	{
		switch (GetIndexUnsafe())
		{
<#foreach (var n in range) {#>
			case <#=n#>: return f<#=n#>(Get<T<#=n#>>());
<#}#>
			default: throw new InvalidInstanceException();
		}
	}

	public void Switch(<#=switchParams#>)
	{
		switch (GetIndexUnsafe())
		{
<#foreach (var n in range) {#>
			case <#=n#>: a<#=n#>(Get<T<#=n#>>()); break;
<#}#>
			default: throw new InvalidInstanceException();
		}
	}

	public static ImmutableArray<Type> Types { get; } = [
<#foreach (var n in range) {#>
		typeof(T<#=n#>),
<#}#>
	];

	static <#=duName#> IDu<<#=duName#>>.Deserialize(ref Utf8JsonReader reader, JsonSerializerOptions options)
	{
<#foreach (var n in range) {#>
		if (JsonSerializer.TryDeserialize<T<#=n#>>(ref reader, options, out var v<#=n#>) && v<#=n#> is not null)
			return v<#=n#>;
<#}#>
		throw new JsonException("No match was found for converting the JSON into a " + typeof(<#=duName#>).NameWithGenericArguments);
	}

	public override String ToString() => Visit<ToStringVisitor, String>(default);

	public override Int32 GetHashCode() => Visit<GetHashCodeVisitor, Int32>(default);

	public override Boolean Equals([NotNullWhen(true)] Object? obj) => obj switch
	{
		<#=duName#> du => Equals(du),
<#foreach (var n in range) {#>
		T<#=n#> t when GetIndex() == <#=n#> => Get<T<#=n#>>().Equals(t),
<#}#>
		IDu du => Visit<DuEqualityVisitor<IDu>, Boolean>(new(du)),
		_ => false
	};

	public Boolean Equals(<#=duName#> other) => Visit<DuEqualityVisitor<<#=duName#>>, Boolean>(new(other));

	public static Boolean operator ==(<#=duName#> left, <#=duName#> right) => left.Equals(right);
	public static Boolean operator !=(<#=duName#> left, <#=duName#> right) => !(left == right);
}
<#
	// var templateDirectory = Path.GetDirectoryName(Host.TemplateFile) ?? throw new("ruh roh");
	// var outputFilePath = Path.Combine(templateDirectory, $"Du_{i + 1}.cs");
	// File.WriteAllText(outputFilePath, this.GenerationEnvironment.ToString());
	// this.GenerationEnvironment.Remove(0, this.GenerationEnvironment.Length);
}
#>
